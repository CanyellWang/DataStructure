### 什么是堆
堆是一棵完全二叉树，对于任意非叶子节点，需要满足如下性质：  

* 节点的关键字不小于（或不大于）左右孩子节点的关键字

前者叫大根堆，后者叫小根堆。  

---

### 基本操作（以小根堆为例）

* 建堆：  
建堆就是一个不断<strong>调整堆</strong>的过程。从length/2处（数组的中间位置）开始，向前调整一直到第一个元素。  
* 调整堆：  
在建堆、向堆中插入元素、堆排序时，都会调整堆。其基本过程是：  
    * 对于某个节点：
    	* 如果它是叶子节点，则<strong>调整结束</strong>
    	* 如果它只有左孩子，则<em>按需</em>调整该节点和其左孩子的关键字，然后<strong>调整结束</strong>
        * 如果该节点的关键字不大于其左右孩子节点的关键字，则<strong>调整结束</strong>
        * 否则，将该节点的关键字 与 其左右孩子节点中关键字较小者 进行互换
        * 然后，从发生互换的位置（也就是左孩子节点或右孩子节点的位置）按照上面的流程，继续向下调整

---

### 堆排序

* 首先将输入数组<strong>堆化</strong>
* 不断的将堆中的第一个元素 和 最后一个元素 进行置换，此时，最后一个元素是堆中最小的元素。并且需要从第一个元素处开始调整堆。然后将倒数第二个元素，作为新的最后一个元素
* 重复执行，过程2，一直到第二个元素成为最后一个元素

---

### topk问题
topk问题是从含有n个元素的数组中，找出前k大的元素。  
解决topk问题的基本思路是：  

* 先将数组的前k个元素调整成一个<strong>小根堆</strong>  
* 然后从第k+1个元素开始，逐个比较元素和堆的根的大小，如果元素不大于堆的根，则继续下一次比较，否则将元素和堆的根互换，并调整堆，重复执行这个过程，一直到数组的最后一个元素

---

### 时间复杂度分析

* 建堆的时间复杂度：  
设树的深度为k（根据完全二叉树的性质，可得到k = 向下取整(log<sub>2</sub>n) + 1），在最坏的情况下，第1层（2<sup>0</sup>个节点）向下调整k-1次，第二层（2<sup>1</sup>个节点）向下调整k-2次，。。。，第k-1层（2<sup>k-2</sup>个节点）向下调整1次，所以最坏的情况下的时间复杂度是：  
2<sup>0</sup> * (k - 1) + 2<sup>1</sup> * (k - 2) + ... + 2<sup>k-2</sup> * (k - (k - 1)) ===&gt;  
k * (2<sup>0</sup> + ... + 2<sup>k-2</sup>) - (1 * 2<sup>0</sup> + ... + (k-1) * 2<sup>k-2</sup>) ===&gt;  
k * (2<sup>k-1</sup> - 1) - (1 * 2<sup>1</sup> + 2 * 2<sup>2</sup> + ... + (k-2) * 2<sup>k-2</sup> + (k-1) * 2<sup>k-1</sup> - 1 * 2<sup>0</sup> - ... - (k-1) * 2<sup>k-2</sup>) ===&gt;  
k * (2<sup>k-1</sup>-1) - ((k-1) * 2<sup>k-1</sup> - 1 - (2<sup>1</sup> + ... + 2<sup>k-2</sup>)) ===&gt;  
k * 2<sup>k-1</sup> -k - (k-1) * 2<sup>k-1</sup> + 1 + 2<sup>k-1</sup> - 1 ===&gt;  
2<sup>k</sup> - k ===&gt;  
n - log<sub>2</sub>n ===&gt;  
n  
经过运算，可以得到建堆的时间复杂度是O(n)

* 堆排序的时间复杂度  
在最坏的情况下，时间复杂度是：  
log<sub>2</sub>(n-1) + log<sub>2</sub>(n-2) + ... + log<sub>2</sub>2 ===&gt;  
log<sub>2</sub>(2<sup>(log<sub>2</sub>(n-1) + log<sub>2</sub>(n-2) + ... + log<sub>2</sub>2)</sup>) ===&gt;  
log<sub>2</sub>(2<sup>log<sub>2</sub>(n-1)</sup> * ... * 2<sup>log<sub>2</sub>2</sup>) ===&gt;  
log<sub>2</sub>((n-1) * (n-2) * ... * 2) ===&gt;  
log<sub>2</sub>((n-1)!) 根据[斯特林公式](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E5%85%AC%E5%BC%8F/9583086?fr=aladdin) ===&gt;  
n * log<sub>2</sub>n
经过运算，可以得到建堆的时间复杂度是O(nlogn)

* topk问题的时间复杂度
在最坏的情况下，时间复杂度是：  
log<sub>2</sub>k * (n - k) ===&gt;  
n * log<sub>2</sub>k  
经过运算，可以得到建堆的时间复杂度是O(nlogk)

---

### 空间复杂度
因为堆排序是<strong>原地排序</strong>，所以在不使用递归的情况下，空间复杂度是O(1)  

---

### 额外说明

* 对于有n个节点的二叉树，其分支数量是n - 1，并且这些分支都是由度为1和度为2的结点射出的，所以，n1 + 2n2 = n - 1，结合 n0 + n1 + n2 = n，可以推出 n0 = n2 + 1。  
    * 在完全二叉树中，度为1的节点，要么有0个，要么有1个，所以 2n0 - 1 + n1 = n，n0 = n/2 或 n0 = (n+1)/2，故在完全二叉树中，叶子节点的数量是：向上取整(n/2)  
* 设m = a<sup>x</sup>，n = a<sup>y</sup>，所以mn = a<sup>(x+y)</sup>；x = log<sub>a</sub>m；y=log<sub>a</sub>n。所以log<sub>a</sub>mn = log<sub>a</sub>m + log<sub>a</sub>n  
* log(mn) = logm + logn，所以logm<sup>n</sup> = log(m * m * ... * m) = logm + ... + logm = nlogm