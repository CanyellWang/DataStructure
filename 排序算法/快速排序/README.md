### 快速排序算法  

1. 从序列中选择一个元素作为基准元素（pivot），通常选择序列的第一个元素  
2. 通过一次排序将序列分成两部分，其中左面的部分都小于基准元素，右面的部分都大于基准元素，这样基准元素恰好在排序后应该在的位置上  
3. 以相同的方式，对左右两部分进行排序，直到整个序列有序  

---

### 时间复杂度和空间复杂度分析  

**当选择的基准元素在数组的中间位置上，并且恰好是数组的中间值的时候**，此时只需要进行n次比较。但是在快排中，进行了**递归调用**，所以基础操作的频度是：

n + 2<sup>1</sup> \* n/2<sup>1</sup>  
&nbsp;&nbsp;+ 2<sup>2</sup> \* n/2<sup>2</sup>    
&nbsp;&nbsp;&nbsp;&nbsp;+ 2<sup>3</sup> \* n/2<sup>3</sup>   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + 2<sup>4</sup> \* n/2<sup>4</sup>  
...    
一直到n/2<sup>x</sup> 等于 1，所以最好情况下的时间复杂度是nlogn  

**当数组是倒序，并且选择第一个元素作为基准元素的时候**，一次排序下来会置换n次元素，并且数组分为两部分，其中一部分有n-1个元素，另外一部分有0个元素，所以基础操作的频度是:  

n + (n - 1) + (n - 2) + ... + 1 = n(n+1)/2 = n<sup>2</sup>/2 + n / 2    
所以最坏的情况下的时间复杂度是n<sup>2</sup>  

在一次排序中，快排耗费的空间是常数级的，但是需要递归logn到n次，所以空间复杂度在最好情况下是logn，在最坏情况下是n。  

