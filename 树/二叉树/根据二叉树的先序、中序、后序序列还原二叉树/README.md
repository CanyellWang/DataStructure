<h3>基本思想</h3>
<em>序列中的元素从1开始编号</em></br>
<ul>
<li>先序遍历的第一个节点（和后序遍历是最后一个节点）一定是根节点</li>
	<ul>
		<li>当根节点是中序遍历的第一个节点时，说明根节点的左子树是空的</br>
			此时，先序遍历的第二个节点是根节点的右孩子节点
		</li>
		<li>当根节点是中序遍历的最后一个节点时，说明根节点的右子树是空的</br>
			此时，先序遍历的第二个节点是根节点的左孩子节点
		</li>
		<li>否则，根节点的左右子树都不为空</br>
			此时，先序遍历的第二个节点是根节点的左孩子节点；后续遍历的倒数第二个节点是根节点的右孩子节点
		</li>
	</ul>
<span>通过上面的推断，可以<strong>找到根节点及其左右孩子节点，并建立三者之间的关系</strong>。接下来只要找到左子树的先序，中序，后序序列和右子树的先序，中序，后序序列，然后用上面的方式递归的处理左右子树就可以将所有的节点之间的关系建立起来。</span>
<li>根据先序，中序，后序序列获取左右子树的先序，中序，后序序列</li>
	<ul>
		<li>如果根节点的左子树为空，则先序序列从第二元素一直到最后一个元素的子序列是右子树的先序序列
		</li>
		<li>如果根节点的左子树为空，则中序序列从第二个元素一直到最后一个元素的子序列是右子树的中序序列
		</li>
		<li>如果根节点的左子树为空，则后序序列从第一个元素一直到倒数第二个元素的子序列是右子树的后序序列
		</li>
		<li>如果根节点的右子树为空，则先序序列从第二个元素一直到最后一个元素的子序列是左子树的先序序列
		</li>
		<li>如果根节点的右子树为空，则中序序列从第一个元素一直到倒数第二个元素的子序列是左子树的中序序列</li>
		<li>如果根节点的右子树为空，则后序序列从第一个元素一直到倒数第二个元素的子序列是左子树的后序序列</li>
		<li>否则，</br>
			<ul>
				<li>找到根的右孩子节点在先序序列中的位置pos，则先序序列从第二个元素到第pos-1个元素的子序列是左子树的先序序列；先序序列从第pos个元素一直到最后一个元素的子序列是右子树的先序序列</li>
				<li>找到根节点在中序序列中的位置pos，则中序序列从第一个元素到第pos-1个元素的子序列是左子树的中序序列；中序序列从第pos+1个元素到最后一个元素的子序列是右子树的中序序列</li>
				<li>找到根的左孩子节点在后序序列中的位置pos，则后序序列从第一个元素到第pos个元素的子序列是左子树的后序序列；后序序列从第pos+1个元素到倒数第二个元素的子序列是右子树的后序序列</li>
			</ul>
		</li>
	</ul>
</ul>
<hr></hr>
<h3>额外说明</h3>
<ul>
<li>只有树中每个节点所保存的元素都不同时，才能还原成一棵唯一的二叉树。</br>
比如：</br>
<span>
&nbsp;&nbsp;&nbsp;&nbsp;100</br>
&nbsp;&nbsp;&nbsp;/</br>
&nbsp;&nbsp;/</br>
100</br>
</span>
这棵二叉树的先序、中序、后序序列都是100，100。</br>
这个序列既可以还原成上面的二叉树，也可以还原成：</br>
100</br>
&nbsp;&nbsp;&nbsp;&nbsp;\</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;100</br>
</li>
</ul>