<h3>等价关系</h3>
设R是非空集合S上的二元关系，如果R是<strong>自反的</strong>、<strong>对称的</strong>、<strong>传递的</strong>，则称R是S上的等价关系。</br>
<ul>
	<li><strong>自反性</strong>：如果元素a属于集合S，则(a, a)属于R</br>∀ a ∈ S =&gt; (a, a) ∈ R</li>
	<li><strong>对称性</strong>：如果(a, b)属于R，且a不等于b，则(b, a)属于R</br>(a, b) ∈ R ∧ a ≠ b =&gt; (b, a) ∈ sR</li>
	<li><strong>传递性</strong>：如果(a, b)属于R，(b, c)属于R，则(a, c)属于R</br>(a, b) ∈ R, (b, c) ∈ R =&gt; (a, c) ∈ R</li>
</ul>
如果(a, b) ∈ R，则称a和b是等价的，记作 a ~ b。</br>
比如，同班同学 和 同乡 是等价关系；相似三角形 和 全等三角形 是等价关系。。。
<hr></hr>
<h3>树的双亲表示法</h3>
用一个<em>链表</em>存储树的每一个结点；每个结点包含两个域：数据域---用来保存数据，指针域---用来指示双亲节点在链表中的索引。</br>
因为根节点没有双亲节点，所以根节点的指针域的值是负的，可以利用这个负值来表示，树中节点的数量。</br>
在双亲表示法中，便于寻找根节点 和 父节点。但是寻找子节点需要遍历所有节点。
<hr></hr>
<h3>如何划分等价类</h3>
按R将S划分成若干个不相交的子集S1，S2，。。。，Sn（它们的并集是S），则称这些子集是S的<strong>等价类</strong>。</br>
假设集合S有n个元素，m个形如(x, y)(x, y ∈ S)的<strong>等价偶对</strong>确定了等价关系R。则将S划分成等价类的算法是：</br>
<ul>
	<li>令集合S中的每个元素 各自 形成一个只包含单个结点的子集，记作S1，S2。。。Sn</li>
	<li>依次读入m个等价偶对，对于每一个偶对(x, y)，设x属于S<sub>i</sub>，y属于S<sub>j</sub>，当S<sub>i</sub>不等于S<sub>j</sub>时，可以将S<sub>i</sub>合并到S<sub>j</sub>，并将S<sub>i</sub>置空（也可以将S<sub>j</sub>合并到S<sub>i</sub>，并将S<sub>j</sub>置空）</li>
</ul>
<strong><em>值得注意的是：在进行合并的时候，如果总是将节点多的树合并到节点少的树，会导致树的高度变大，进而导致 寻找节点所属的树的根节点的时候，时间会增大。</em>因此，在合并的时候，选择将节点少的树合并到节点多的树，并且利用根节点的游标域保存该棵树的节点数量的负值。</strong>
